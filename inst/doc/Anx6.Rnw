%\VignetteIndexEntry{Annexe Chapitre 6}
%\VignetteDepends{}
%\VignetteKeywords{ts}
%\VignettePackage{caschrono}
\documentclass{article}
\usepackage{Sweave}
\usepackage{times}
\usepackage{mathptm}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{pratiquer}
\setkeys{Gin}{width=0.95\textwidth}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator{\BB}{BB}
\DeclareMathOperator{\BBN}{BBN}
\DeclareMathOperator{\rang}{rang}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\V}{V}
\DeclareMathOperator{\C}{Cov}
\DeclareMathOperator{\Prob}{Pr}
\DeclareMathOperator{\diag}{diag}
\def\agra{\boldsymbol{a}} % a grave
%
\def\alg{\boldsymbol{\alpha}}
\def\b{\mbox{\bf b}}
%
\def\B{\mbox{\bf B}}
\def\BB#1{\mbox{BB}(0,\sigma_{#1}^2)}
\def\bm{\mbox{B}}
\def\betg{\boldsymbol{\beta}}
\def\bar#1#2{\overline{#1}_{#2}} % surligné indicé
\def\bgr{\mbox{\bf b}}
\def\bla{\mbox{~}}
\def\blb{\mbox{~~}}
%
\def\card{\mbox{card}}
\def\corr{\mbox{corr}}
\def\cov{\mbox{\sf cov}}
\def\cv{\mbox{CV}}
%
\def\D{\mbox{\bf D}}
\def\d{\bf d}
\def\degr{^{\circ}}
\def\deltag{\boldsymbol{\delta}}
\def\Deltag{\boldsymbol{\Delta}} % ligne 64
\def\diag{\mbox{diag}}
\def\dir{\mbox{\tiny{DIR}}}
\def\dsp{\displaystyle}
%
\def\e{\mbox{\bf e}}
\def\eps{{\bf \epsilon}}
\def\esp{\mbox{\sf E}}
\def\eti{\tilde{\epsilon}}

\def\F{\mbox{\bf F}}
\def\g{\mbox{\bf g}}
\def\gamg{\boldsymbol{\Gamma}}
\def\gamgp{\boldsymbol{\gamma}}
\def\hors{\mathbin{\in\mkern-12mu/}}

\def\I{\mbox{\bf I}}
\def\indic{\mathrm{I\mkern-8muI}}
\def\ie{c'est-à-dire}
\def\iid{\sim_{\mbox{i.i.d.}}}
\def\lm{\mbox{L}}

\def\mapsous#1{\smash{ \mathop{\longrightarrow}\limits_{#1}}} %
\def\mapsur#1{\smash{ \mathop{\longrightarrow}\limits^{#1}}}  %
\def\M{\mbox{\bf M}}
\def\mug{\boldsymbol{\mu}}
\def\nor{\mathcal{N}}
\def\nug{\boldsymbol{\nu}}
\def\Nx{\mbox{\bf N}}
\def\P{\mbox{\bf P}}
\def\Phig{\boldsymbol{\Phi}}
\def\phig{\boldsymbol{\phi}}
\def\poi{\mbox{\cal P}}
\def\pr{\mbox{Pr}}
\def\prim{^{\boldsymbol{\prime}}}
\def\px{\mbox{\bf x}}

\def\Rho{\boldsymbol{\rho}}
\def\rl{\mathbin{I\mkern-8muR}} % Reel
\def\RR{\textsf{R}\/}

\newcommand{\sig}[2]{\Sigma_{{#1},{#2}}}
\def \sitst{\textsf{SiteST}\/}
\def\SP{\texttt{S-PLUS}\/}
\def\T{\mbox{\bf T}}
\def\tr{\triangle}
\def\t{\mbox{\bf t}}
\def\tra{\mbox{tr}}

\def\U{\mbox{\bf U}}
\def\Unif{\emph{Unif}}
\def\u{\mbox{\bf u}}
\def\v{\mbox{\bf v}}

\def\w{\mbox{\bf w}}
\def\var{\mbox{\sf var}}
\def\W{\mbox{\bf W}}
\def\X{\textbf{X}}
\def\x{\textbf{x}}

\def\Y{\textbf{Y}}
\def\yg{\textbf{y}}
\def\y0{y^0}

\def\Z{\textbf{Z}}
\def\z{ \textbf{z}}
\def\zer{\large{0}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\urlstyle{sf}
\def\rmdefault{cmr}

%%%% pour les chiffres des équations
\makeatletter
\renewcommand\theequation{\thesection.\arabic{equation}}
\@addtoreset{equation}{section}
\makeatother

\title{Lissage exponentiel (compléments du Chapitre 6)}
\author{Yves Aragon\footnote{aragon@cict.fr} \cr
{\normalsize Université Toulouse 1 Capitole} }
\begin{document}
\maketitle
\setcounter{section}{6}
\renewcommand{\thefootnote}{\arabic{footnote}}

\SweaveOpts{keep.source=TRUE}
<<echo=FALSE>>=
owidth <- getOption("width") # largeur des sorties
options(width=60, continue="+ ","warn"=-1 )
.PngNo <- 0
nom.fich = "./Figures/anx6-bitmap-"
@
% les différents types de graphiques
%  ancien
<<label=bfig,echo=FALSE,eval=FALSE>>=
.PngNo <- .PngNo + 1; file = paste(rep.ima,nom.fich, .PngNo, sep="")
pdf(file=paste(file,".pdf",sep=""), width = 7, height = 7, pointsize = 12, bg = "white")
@

<<label=bfigps,echo=FALSE,eval=FALSE>>=
postscript(file=paste(file,".ps",sep=""), width = 7, height = 7, pointsize = 12, bg = "white",horizontal= FALSE,paper="special")
@


% 1111111111111
<<label=bfig1,echo=FALSE,eval=FALSE>>=
.PngNo <- .PngNo + 1; file = paste(rep.ima,nom.fich, .PngNo, sep="")
pdf(file=paste(file,".pdf",sep=""), width = 5, height = 2, pointsize = 10, bg = "white")
@

<<label=bfigps1,echo=FALSE,eval=FALSE>>=
postscript(file=paste(file,".ps",sep=""),  width = 5, height =2, pointsize = 10, bg = "white",horizontal= FALSE,paper="special")
@
% 222222222222222
<<label=bfig2,echo=FALSE,eval=FALSE>>=
.PngNo <- .PngNo + 1; file = paste(rep.ima,nom.fich, .PngNo, sep="")
pdf(file=paste(file,".pdf",sep=""), width = 3.9, height = 3.1, pointsize = 10, bg = "white")
@

<<label=bfigps2,echo=FALSE,eval=FALSE>>=
postscript(file=paste(file,".ps",sep=""), width = 3.9, height = 3.1,   pointsize = 10, bg = "white",horizontal= FALSE,paper="special")
@
%   3333333333333333333333333333

<<label=bfig3,echo=FALSE,eval=FALSE>>=
.PngNo <- .PngNo + 1; file = paste(rep.ima,nom.fich, .PngNo, sep="")
pdf(file=paste(file,".pdf",sep=""), width = 5.92, height = 6.74, pointsize = 10, bg = "white")
@
<<label=bfigps3,echo=FALSE,eval=FALSE>>=
postscript(file=paste(file,".ps",sep=""), width = 5.92, height = 6.74, pointsize = 10, bg = "white",horizontal= FALSE,paper="special")
@

<<label=bfig4,echo=FALSE,eval=FALSE>>=
.PngNo <- .PngNo + 1; file = paste(rep.ima,nom.fich, .PngNo, sep="")
pdf(file=paste(file,".pdf",sep=""), width = 6, height = 6, pointsize = 10, bg = "white")
@
<<label=bfigps4,echo=FALSE,eval=FALSE>>=
postscript(file=paste(file,".ps",sep=""), width = 6, height = 6, pointsize = 10, bg = "white",horizontal= FALSE,paper="special")
@

<<label=zfig2,echo=FALSE,eval=FALSE>>=
dev.null <- dev.off()
@

<<label=zfiginclude,echo=FALSE,eval=FALSE>>=
cat("\\includegraphics[width=0.9\\textwidth]{", file, "}\n\n", sep="")
@


\subsection*{Somme finie ou infinie}

La somme des poids
\[
c_i = \alpha (1 - \alpha)^i,\; i=0, 1,\cdots
\]
fait 1 si l'on va jusqu'à l'infini. Examinons la somme réelle des poids quand on arrête la somme à 10, 20, 30, 40 observations, pour alpha = .1, .2,.3..

{\small
<<label=alpha>>=
alpha= seq(.1,.3, by=.1)
arret = seq(10,40,by=10)
n.al= length(alpha) ; n.arret = length(arret)
cumul = matrix(0,nrow=n.al,ncol=n.arret)
rownames(cumul) =as.character(alpha)
colnames(cumul) = as.character(arret)
poids = function(alf,i)
{
# renvoie les poids alpha*(1 - alpha)^j, j=0, i-1
wgh= rep(0,i)
wgh[1]= alf
for(k in 2:i )
{wgh[k] = wgh[k-1]*(1 - alf)}
sum(wgh)
}
for (m in 1:length(alpha))
{
for (n in 1:length(arret))
{
cumul[m,n] = poids(alpha[m],arret[n])
}
}
round(cumul,digits=2)
@
}
On voit qu'on atteint 0.99 en 40 observations si  $\alpha = 0.1$,  en 20 observations si $\alpha = 0.2$
et en moins de 20 observations si $\alpha = 0.3$. L'approximation est donc acceptable.

\begin{Exercice}[Compléments sur \code{fmsales}]
 \begin{enumerate}

\item Examinons la  sortie \verb"ets0".

{\small
<<>>=
require(forecast)
require(expsmooth)
require(caschrono)
ets0 = ets(fmsales,model="ANN")
summary(ets0)
str(ets0, width = 60, strict.width = "cut")
@
}
\noindent
C'est une liste qui contient entre autres : les résidus, \code{residuals(ets0)}, {\ie} les $ \widehat{\epsilon}_t$ et les valeurs ajustées
\verb"ets0$fit", {\ie} les $\widehat{y}_t$, qui sont également les prédictions à l'horizon 1 sur la période d'observation, la série état,
\verb"ets0$states".

\item L'état initial est noté \code{l}, on le trouve en \verb"$fit$par[2]" et dans \verb"$states[1]".

\item   \verb"ets0$mse" = \verb"ets0$sigma2" car le prédicteur est sans biais et donc l'erreur quadratique moyenne se confond avec la variance de l'innovation.

\item Les paramètres de ce modèle sont l'état initial et alpha.

\item Blancheur du résidu.

Si l'on veut examiner la blancheur du bruit après estimation, on peut exécuter :

{\small
<<label=testbl>>=
Box.test.2(residuals(ets0), nlag = c(3,6,9))
@
}
\noindent
Donc le modèle est satisfaisant.
\end{enumerate}

\end{Exercice}


\begin{Exercice}[Lissage exponentiel simple par la méthode de  Holt-Winters]

\begin{enumerate}
\item Faire la prévision de \code{fmsale} à l'horizon 4 à l'aide de la fonction \code{HoltWinters()} ;
\item Comparer dans les deux approches, les valeurs du paramètre $\alpha$, les vecteurs donnant le niveau.
\end{enumerate}
\end{Exercice}

\textbf{Réponse.}

{\small
<<>>=
(ets0.hw=HoltWinters(fmsales, alpha = NULL, beta = FALSE, 
gamma =FALSE))
@
}

Et si l'on veut dessiner les deux ajustements par \code{ets}  et par \code{HoltWinters}


{\small
\begin{verbatim}
plot(ets0.hw$fitted[,1], ets0$fitted[-1])
\end{verbatim}
}


%\begin{Exercice}[Moyenne localement constante ou moyenne localement  linéaire]
%On a vu, notamment par le test de blancheur du résidu,  que la série \code{fmsales} a une moyenne localement constante (mlc).
%Le modèle à moyenne localement linéaire (mll) que nous venons  de lui ajuster est donc sans doute inutilement compliqué.
%\begin{enumerate}
%\item Comparer les critères d'information dans les deux modélisations.
%\item Les mesures d'erreur intra-échantillon sont nécessairement plus faibles avec une mll qu'avec une mlc.
%Calculer la variation relative de ces mesures.
%\item Donner une mesure de la variabilité de la pente dans la mll. Commenter.
%\item Quel modèle retenir pour cette série ?
%\end{enumerate}
%\end{Exercice}
%
%Réponse.
%
%Notons que maintenant l'état est bien un vecteur à deux composantes notées  \code{l} et \code{b}.
%
%
%Les critères d'information pour le SES sont :
%
%{\small
% \begin{verbatim}
%   AIC   AICc    BIC
%416.97 417.17 421.22
% \end{verbatim}
%}
%\noindent
% chacun est inférieur à son correspondant pour le lissage exponentiel double.
%De plus le paramètre de mise à jour de la pente (\verb"beta  = 0.0001") est très faible, ainsi que la pente  initiale.
%
%
%Calculons la variabilité des composantes.
%
%{\small
%<<label=fmsales.vari, echo=TRUE,eval=TRUE, results=verbatim>>=
%summary(ses.2$states)
%@
%}
%\noindent
%On voit que la pente est pratiquement constante et très faible.
%La structure de l'objet en sortie  donne notamment une estimation
%du vecteur état. Sa première composante correspond au niveau local et la deuxième à la pente.

\end{document}